package com.CMPUT301F22T25.malwarepolymorphism.features.ingredients.UI;

import android.annotation.SuppressLint;
import android.os.Bundle;
import android.util.Log;
import android.view.View;

import androidx.appcompat.app.AppCompatActivity;

import com.CMPUT301F22T25.malwarepolymorphism.databinding.ActivityIngredientDetailsBinding;
import com.CMPUT301F22T25.malwarepolymorphism.features.ingredients.domain.data.IngredientAttributeBundle;
import com.CMPUT301F22T25.malwarepolymorphism.features.ingredients.domain.entities.Ingredient;
import com.CMPUT301F22T25.malwarepolymorphism.features.ingredients.domain.usecases.AddIngredientUseCase;
import com.CMPUT301F22T25.malwarepolymorphism.features.ingredients.domain.usecases.DeleteIngredientUseCase;
import com.CMPUT301F22T25.malwarepolymorphism.features.ingredients.domain.usecases.GetIngredientUseCase;
import com.CMPUT301F22T25.malwarepolymorphism.features.ingredients.domain.usecases.ModifyIngredientUseCase;
import com.google.android.material.datepicker.CalendarConstraints;
import com.google.android.material.datepicker.DateValidatorPointForward;
import com.google.android.material.datepicker.MaterialDatePicker;

import java.sql.Date;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.time.Instant;
import java.util.Calendar;
import java.util.Locale;
import java.util.Objects;
import java.util.TimeZone;

import javax.inject.Inject;

import dagger.hilt.android.AndroidEntryPoint;


@AndroidEntryPoint
public class IngredientDetailsActivity extends AppCompatActivity {


    @Inject
    ModifyIngredientUseCase modifyIngredientUseCase;

    @Inject
    GetIngredientUseCase getIngredientUseCase;

    @Inject
    AddIngredientUseCase addIngredientUseCase;

    @Inject
    DeleteIngredientUseCase deleteIngredientUseCase;

    ActivityIngredientDetailsBinding binding;

    Instant currentlySelectedBestBefore;
    DateFormat dateFormat;

    @SuppressLint("SetTextI18n")
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        binding = ActivityIngredientDetailsBinding.inflate(getLayoutInflater());
        setContentView(binding.getRoot());

        // Set up the format we are going to use.
        dateFormat = new SimpleDateFormat("dd MMM yyyy", Locale.CANADA);
        dateFormat.setTimeZone(TimeZone.getTimeZone("UTC"));

        // Set up the calender instance.
        Calendar calendar = Calendar.getInstance(TimeZone.getTimeZone("UTC"), Locale.CANADA);
        currentlySelectedBestBefore = Instant.ofEpochMilli(calendar.getTimeInMillis());
        binding.bestBeforeDateTextView.setText(
                dateFormat.format(Date.from(currentlySelectedBestBefore)));

        // Set a constraint to allow only dates in the future.
        CalendarConstraints.Builder calendarConstraints =
                new CalendarConstraints.Builder().setValidator(DateValidatorPointForward.now());

        // Build the date picker.
        MaterialDatePicker.Builder<Long> builder = MaterialDatePicker.Builder.datePicker();
        builder.setInputMode(MaterialDatePicker.INPUT_MODE_CALENDAR)
                .setTitleText("Select Best Before Date")
                .setSelection(currentlySelectedBestBefore.toEpochMilli())
                .setCalendarConstraints(calendarConstraints.build());
        MaterialDatePicker<Long> picker = builder.build();

        // Set up a listener to respond when the user selects a new date.
        picker.addOnPositiveButtonClickListener(this::updateSelectedDate);

        binding.dateButton.setOnClickListener(view -> {
            picker.show(getSupportFragmentManager(), "date");
            Log.d("BBDate", "Clicked on the text field");
        });

        boolean isEditing = getIntent().getBooleanExtra("isEditing", false);

        if (isEditing) {
            String ingredientId = getIntent().getStringExtra("ingredientId");
            binding.deleteIconButton.setVisibility(View.VISIBLE);
            binding.deleteIconButton.setOnClickListener(view -> {
                deleteIngredientUseCase.execute(ingredientId);
                finish();
            });
            binding.titleTextField.setText("Edit Ingredient");
            prePopulateFields(ingredientId);
        }

        binding.cancelButton.setOnClickListener(view -> {
            finish();
        });

        binding.saveButton.setOnClickListener(view -> {

            String description = Objects.requireNonNull(binding.descriptionTextField.getEditText())
                    .getText().toString();
            Instant bestBefore = currentlySelectedBestBefore;
            String location = Objects.requireNonNull(binding.locationSetTextField.getEditText())
                    .getText().toString();
            long amount = Long.parseLong(Objects.requireNonNull(binding.amountTextField.getEditText())
                    .getText().toString());
            String unit = Objects.requireNonNull(binding.unitTextField.getEditText())
                    .getText().toString();
            String category = Objects.requireNonNull(binding.categoryTextField.getEditText())
                    .getText().toString();


            if (/* validate data here*/ false) {
                return;
            }

            IngredientAttributeBundle bundle = new IngredientAttributeBundle(
                    description,
                    amount,
                    unit,
                    location,
                    bestBefore,
                    category
            );

            if (isEditing) {
                String ingredientId = getIntent().getStringExtra("ingredientId");
                modifyIngredientUseCase.execute(ingredientId, bundle);
            } else {
                addIngredientUseCase.execute(bundle);
            }
            finish();
        });
    }

    void prePopulateFields(String ingredientId) {
        Ingredient ingredient = getIngredientUseCase.execute(ingredientId);
        assert ingredient != null;
        currentlySelectedBestBefore = ingredient.getBestBefore();
        Objects.requireNonNull(binding.descriptionTextField.getEditText())
                .setText(ingredient.getDescription());
        Objects.requireNonNull(binding.amountTextField.getEditText())
                .setText(String.valueOf(ingredient.getAmount()));
        Objects.requireNonNull(binding.locationSetTextField.getEditText())
                .setText(ingredient.getLocation());
        binding.amountTextField.getEditText().
                setText(String.valueOf(ingredient.getAmount()));
        Objects.requireNonNull(binding.unitTextField.getEditText())
                .setText(ingredient.getCategory());
        binding.bestBeforeDateTextView.setText(
                dateFormat.format(Date.from(currentlySelectedBestBefore)));
    }

    void updateSelectedDate(long selection) {
        currentlySelectedBestBefore = Instant.ofEpochMilli(selection);
        binding.bestBeforeDateTextView.setText(
                dateFormat.format(Date.from(currentlySelectedBestBefore)));
    }

    ;
}