package com.CMPUT301F22T25.malwarepolymorphism.features.recipes.data;

import androidx.lifecycle.LiveData;
import androidx.lifecycle.MutableLiveData;

import com.CMPUT301F22T25.malwarepolymorphism.features.recipes.domain.data.RecipeAttributeBundle;
import com.CMPUT301F22T25.malwarepolymorphism.features.recipes.domain.data.RecipeRepository;
import com.CMPUT301F22T25.malwarepolymorphism.features.recipes.domain.entities.Recipe;
import com.CMPUT301F22T25.malwarepolymorphism.features.recipes.domain.entities.RecipeIngredientMember;
import com.google.firebase.firestore.CollectionReference;
import com.google.firebase.firestore.DocumentReference;
import com.google.firebase.firestore.FirebaseFirestore;
import com.google.firebase.firestore.ListenerRegistration;
import com.google.firebase.firestore.QueryDocumentSnapshot;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Objects;

import javax.inject.Inject;


/**
 * This class is responsible for handling all the data access for the recipe feature.
 * It uses the Firebase Firestore database to store and retrieve data.
 */

public class FirebaseRecipeRepository implements RecipeRepository {
    final FirebaseFirestore database;
    final CollectionReference recipeCollectionReference;
    private final MutableLiveData<List<Recipe>> liveRecipeData;

    private ListenerRegistration registration;

    /**
     * Constructor for the FirebaseRecipeRepository class.
     * It initializes the database and the collection reference.
     * It also sets up a listener for the database to update the liveRecipeData when the database changes.
     */
    @Inject
    public FirebaseRecipeRepository() {
        liveRecipeData = new MutableLiveData<>(new ArrayList<>());
        database = FirebaseFirestore.getInstance();
        recipeCollectionReference = database.collection("RecipeRepository");

        registration = recipeCollectionReference.addSnapshotListener((queryDocumentSnapshots, error) -> {
            if (queryDocumentSnapshots == null)
                return;

            List<Recipe> recipes = liveRecipeData.getValue();
            assert recipes != null;
            recipes.clear();
            for (QueryDocumentSnapshot doc : queryDocumentSnapshots) {
                recipes.add(getRecipeFromDoc(doc));
            }

            liveRecipeData.postValue(recipes);
        });
    }

    /**
     * This method returns the liveRecipeData.
     * @return recipeBundle
     */
    @Override
    public LiveData<List<Recipe>> getRecipeList() {
        return liveRecipeData;
    }

    /**
     * This method adds a new recipe to the database.
     * @param recipeBundle
     */
    @Override
    public void addRecipe(RecipeAttributeBundle recipeBundle) {
        DocumentReference recipeDoc = recipeCollectionReference.document();
        recipeDoc.set(recipeBundle.toHashMap());
    }

    /**
     * This method modifies an existing recipe in the database.
     * @param modified,
     * @param id
     */
    @Override
    public void modifyRecipe(String id, RecipeAttributeBundle modified) {
        DocumentReference recipeDoc = recipeCollectionReference.document(id);
        recipeDoc.update(modified.toHashMap());
    }

    /**
     *
     * This method deletes an existing recipe in the database.
     * @param id
     */
    @Override
    public void deleteRecipe(String id) {
        recipeCollectionReference
                .document(id)
                .delete();
    }

    /**
     *
     * This method sorts the RecipeData in an order chosen by the user.
     * @param sortByField
     */
    @Override
    public void sortRecipesByField(String sortByField) {
        registration.remove();
        registration = recipeCollectionReference.orderBy(sortByField).addSnapshotListener((value, error) -> {
            if (value == null)
                return;

            List<Recipe> recipes = liveRecipeData.getValue();
            assert recipes != null;
            recipes.clear();
            for (QueryDocumentSnapshot doc : value)
                recipes.add(getRecipeFromDoc(doc));

            liveRecipeData.postValue(recipes);
        });
    }

    /**
     * This method returns a Recipe from the database.
     * @param id
     * @return
     */
    @Override
    public Recipe getRecipe(String id) {
        return Objects.requireNonNull(liveRecipeData
                        .getValue())
                .stream()
                .filter(recipe -> recipe.getId().equals(id))
                .findFirst()
                .orElse(null);
    }

    /**
     * This method converts a QueryDocumentSnapshot into a Recipe.
     * @param  doc
     * @return Recipe
     */
    private Recipe getRecipeFromDoc(QueryDocumentSnapshot doc) {
        List<HashMap<String, Object>> ingredientsList = (List<HashMap<String, Object>>) doc.get("ingredients");
        List<RecipeIngredientMember> ingredients = new ArrayList<>();
        assert ingredientsList != null;
        ingredientsList.forEach(map -> ingredients.add(RecipeIngredientMember.fromHashMap(map)));

        return new Recipe(
                doc.getId(),
                doc.getString("title"),
                doc.getLong("preparationTime"),
                doc.getLong("numOfServings"),
                doc.getString("category"),
                doc.getString("comments"),
                doc.getString("imageUrl"),
                ingredients
        );
    }
}