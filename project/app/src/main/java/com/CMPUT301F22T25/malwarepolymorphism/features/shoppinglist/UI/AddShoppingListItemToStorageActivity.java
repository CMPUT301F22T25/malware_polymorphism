package com.CMPUT301F22T25.malwarepolymorphism.features.shoppinglist.UI;

import android.annotation.SuppressLint;
import android.os.Bundle;

import androidx.appcompat.app.AppCompatActivity;

import com.CMPUT301F22T25.malwarepolymorphism.databinding.ActivityAddShoppingListItemToStorageBinding;
import com.CMPUT301F22T25.malwarepolymorphism.features.common.DateFormatter;
import com.CMPUT301F22T25.malwarepolymorphism.features.ingredients.domain.data.IngredientAttributeBundle;
import com.CMPUT301F22T25.malwarepolymorphism.features.ingredients.domain.data.IngredientRepository;
import com.CMPUT301F22T25.malwarepolymorphism.features.recipes.domain.entities.RecipeIngredientMember;
import com.google.android.material.datepicker.MaterialDatePicker;

import java.time.Instant;
import java.util.Calendar;
import java.util.Locale;
import java.util.Objects;
import java.util.TimeZone;

import javax.inject.Inject;

import dagger.hilt.android.AndroidEntryPoint;

@AndroidEntryPoint
public class AddShoppingListItemToStorageActivity extends AppCompatActivity {

    @Inject
    IngredientRepository repository;

    ActivityAddShoppingListItemToStorageBinding binding;

    Instant currentlySelectedBestBefore;

    @Inject
    DateFormatter dateFormat;

    @Inject
    MaterialDatePicker.Builder<Long> datePickerBuilder;

    @SuppressLint("SetTextI18n")
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        binding = ActivityAddShoppingListItemToStorageBinding.inflate(getLayoutInflater());
        setContentView(binding.getRoot());

        // Set up the calender instance.
        Calendar calendar = Calendar.getInstance(TimeZone.getTimeZone("UTC"), Locale.CANADA);
        currentlySelectedBestBefore = Instant.ofEpochMilli(calendar.getTimeInMillis());
        binding.ingredientDateTextFieldInput.setText(
                dateFormat.formatDate(currentlySelectedBestBefore));

        // Build the date picker.
        datePickerBuilder.setSelection(currentlySelectedBestBefore.toEpochMilli());
        MaterialDatePicker<Long> picker = datePickerBuilder.build();

        // Set up a listener to respond when the user selects a new date.
        picker.addOnPositiveButtonClickListener(this::updateSelectedDate);
        binding.ingredientDateTextFieldInput.setOnClickListener(view -> picker.show(
                getSupportFragmentManager(), "date"));

        RecipeIngredientMember shoppingListItem = (RecipeIngredientMember) getIntent().getExtras().get("shoppingListItem");
        binding.titleTextField.setText("Complete purchase");
        prePopulateFields(shoppingListItem);

        binding.cancelButton.setOnClickListener(view -> finish());

        binding.saveButton.setOnClickListener(view -> {
            String description = Objects.requireNonNull(binding.descriptionTextField.getEditText())
                    .getText().toString().trim();
            Instant bestBefore = currentlySelectedBestBefore;
            String location = Objects.requireNonNull(binding.locationSetTextField.getEditText())
                    .getText().toString().trim();
            String amountInput = Objects.requireNonNull(binding.amountTextField.getEditText())
                    .getText().toString().trim();
            String unit = Objects.requireNonNull(binding.unitTextField.getEditText())
                    .getText().toString().trim();
            String category = Objects.requireNonNull(binding.categoryTextField.getEditText())
                    .getText().toString().trim();

            boolean valid = binding.descriptionTextFieldInput.getError() == null;

            if (location.isEmpty()) {
                binding.locationSetTextField.setError("Location cannot be empty");
                valid = false;
            }
            if (amountInput.isEmpty()) {
                binding.amountTextField.setError("Amount must be greater than 0");
                valid = false;
            }
            if (unit.isEmpty()) {
                binding.unitTextField.setError("Unit cannot be empty");
                valid = false;
            }
            if (category.isEmpty()) {
                binding.categoryTextField.setError("Category cannot be empty");
                valid = false;
            }
            if(!valid) {
                return;
            }

            IngredientAttributeBundle bundle = new IngredientAttributeBundle(
                    description,
                    Float.parseFloat(amountInput),
                    unit,
                    location,
                    bestBefore,
                    category
            );
            repository.addIngredient(bundle);
            finish();
        });
    }

    void prePopulateFields(RecipeIngredientMember ingredient) {
        assert ingredient != null;
        Objects.requireNonNull(binding.descriptionTextField.getEditText())
                .setText(ingredient.getDescription());
        Objects.requireNonNull(binding.amountTextField.getEditText())
                .setText(String.valueOf(ingredient.getAmount()));
        Objects.requireNonNull(binding.unitTextField.getEditText())
                .setText(ingredient.getUnit());
        Objects.requireNonNull(binding.categoryTextField.getEditText())
                .setText(ingredient.getCategory());
        binding.ingredientDateTextFieldInput.setText(
                dateFormat.formatDate(currentlySelectedBestBefore));
    }

    void updateSelectedDate(long selection) {
        currentlySelectedBestBefore = Instant.ofEpochMilli(selection);
        binding.ingredientDateTextFieldInput.setText(
                dateFormat.formatDate(currentlySelectedBestBefore));
    }
}
