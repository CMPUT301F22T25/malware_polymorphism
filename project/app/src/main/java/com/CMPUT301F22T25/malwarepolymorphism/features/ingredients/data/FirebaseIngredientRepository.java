package com.CMPUT301F22T25.malwarepolymorphism.features.ingredients.data;

import androidx.lifecycle.LiveData;
import androidx.lifecycle.MutableLiveData;

import com.CMPUT301F22T25.malwarepolymorphism.features.ingredients.domain.data.IngredientAttributeBundle;
import com.CMPUT301F22T25.malwarepolymorphism.features.ingredients.domain.data.IngredientRepository;
import com.CMPUT301F22T25.malwarepolymorphism.features.ingredients.domain.entities.Ingredient;
import com.google.firebase.firestore.CollectionReference;
import com.google.firebase.firestore.DocumentReference;
import com.google.firebase.firestore.FirebaseFirestore;
import com.google.firebase.firestore.QueryDocumentSnapshot;

import java.sql.Timestamp;
import java.time.Instant;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

import javax.inject.Inject;

/**
 * implements the firebase for the ingredients data storage
 */
public class FirebaseIngredientRepository implements IngredientRepository{
    final FirebaseFirestore database;
    final CollectionReference ingredientCollectionReference;
    private MutableLiveData<List<Ingredient>> liveIngredientData;

    @Inject
    /**
     * initialize the firebase
     */
    public FirebaseIngredientRepository() {
        liveIngredientData = new MutableLiveData<>(new ArrayList<>());
        database = FirebaseFirestore.getInstance();
        ingredientCollectionReference = database.collection("IngredientRepository");

        ingredientCollectionReference.addSnapshotListener( (queryDocumentSnapshots, error) -> {
            if (queryDocumentSnapshots == null) {
                return;
            }

            List<Ingredient> ingredients = liveIngredientData.getValue();
            assert ingredients != null;
            ingredients.clear();
            for (QueryDocumentSnapshot doc : queryDocumentSnapshots) {
                ingredients.add(getIngredientFromDoc(doc));
            }

            liveIngredientData.postValue(ingredients);
        });
    }

    @Override
    /**
     * update data for ingredient accordingly
     */
    public LiveData<List<Ingredient>> getIngredientsList() {
        return liveIngredientData;
    }

    @Override
    /**
     * adding new ingredient and updating it in firebase accordingly
     */
    public void addIngredient(IngredientAttributeBundle ingredientBundle) {
        DocumentReference ingredientDoc = ingredientCollectionReference.document();
        HashMap<String, Object> ingredientData = getMapFromBundle(ingredientBundle);
        ingredientDoc.set(ingredientData);
    }

    @Override
    /**
     * editing exiting ingredient and updating it in firebase accordingly
     */
    public void modifyIngredient(String id, IngredientAttributeBundle modified) {
        DocumentReference ingredientDoc= ingredientCollectionReference.document(id);
        HashMap<String, Object> ingredientData = getMapFromBundle(modified);
        ingredientDoc.update(ingredientData);
    }

    @Override
    /**
     * sorting existing ingredient and updating it in firebase accordingly
     */
    public void sortIngredientsBy(String sortByField) {
        ingredientCollectionReference.orderBy(sortByField).addSnapshotListener((value, error) -> {
            if (value == null) {
                return;
            }
            List<Ingredient> ingredients = liveIngredientData.getValue();
            assert ingredients != null;
            ingredients.clear();
            for (QueryDocumentSnapshot doc : value) {
                ingredients.add(getIngredientFromDoc(doc));
            }
            liveIngredientData.postValue(ingredients);
        });
    }

    @Override
    /**
     * deleting existing ingredient and updating it in firebase accordingly
     */
    public void deleteIngredient(String id) {
        ingredientCollectionReference
                .document(id)
                .delete();
    }

    @Override
    public Ingredient getIngredient(String id) {
        return liveIngredientData
                .getValue()
                .stream()
                .filter(ingredient -> ingredient.getId().equals(id))
                .findFirst()
                .orElse(null);
    }

    private HashMap<String, Object> getMapFromBundle(IngredientAttributeBundle ingredientBundle){
        HashMap<String, Object> ingredientData = new HashMap<>();
        ingredientData.put("description", ingredientBundle.getDescription());
        Instant bestBeforeInstant = ingredientBundle.getBestBefore();
        long bestBefore = Timestamp.from(bestBeforeInstant).getTime();
        ingredientData.put("bestBefore",bestBefore);
        ingredientData.put("location", ingredientBundle.getLocation());
        ingredientData.put("amount", ingredientBundle.getAmount());
        ingredientData.put("unit", ingredientBundle.getUnit());
        ingredientData.put("category",ingredientBundle.getCategory());
        return ingredientData;
    }

    private Ingredient getIngredientFromDoc(QueryDocumentSnapshot document){
        Timestamp timestamp = new Timestamp(document.getLong("bestBefore"));
        return new Ingredient(
                document.getId(),
                document.getString("description"),
                document.getLong("amount"),
                document.getString("unit"),
                document.getString("location"),
                timestamp.toInstant(),
                document.getString("category")
        );
    }

    private Ingredient getIngredientFromBundle(String id, IngredientAttributeBundle bundle){
        return new Ingredient(
                id,
                bundle.getDescription(),
                bundle.getAmount(),
                bundle.getUnit(),
                bundle.getLocation(),
                bundle.getBestBefore(),
                bundle.getCategory()
        );
    }
}
